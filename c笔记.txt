编译过程
预处理  // 得到.i文件，将所有#include的头文件以及宏定义替换成其真正的内容，预处理之后得到的仍然是文本文件，但文件体积会大很多
编译  // 得到.s文件，将经过预处理之后的程序转换成特定汇编代码
汇编  // 得到.o文件，将汇编代码转换成机器码
链接  // 将多个目标文件以及所需的库文件(.so等)链接生成最终的可执行文件

gcc  // GNU Compiler Collection
gcc -E hello.c > hello.i  // 输出预处理文件
gcc -S hello.c > hello.s  // 输出汇编文件
gcc hello.c -o hello.out -L/usr/lib -lm  // -l，添加链接库，m是数学库libm.a的基本名称，-L，为gcc增加一个搜索链接库的目录
gcc -c hello.c  // 输出目标文件（.o/.obj），hello.o，编译器编译源代码但不执行链接
gcc -o hello.c hello  // 输出可执行文件hello，如果没有-o和后面的参数，gcc编译器默认输出a.out
gcc -g -o hello.c hello  // 想用调试器执行一个可执行文件，在用gcc编译时必须加上-g选项，-g的作用，1、创建符号表，符号表包含了程序中使用的变量名称的列表，2、关闭所有的优化机制，以便程序执行过程中严格按照原来的c代码进行

反汇编
objdump -d hello > hello.txt

静态链接库  // 在链接阶段，会将汇编生成的目标文件（.o/.obj）与引用到的库一起链接打包到可执行文件中
后缀名：
linux  .a  
windows  .lib
优点：
移植方便，程序在运行时与函数库再无关联
缺点：
浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成到一个可执行文件文件中
不方便更新迭代，不能增量更新
linux创建静态库：
ar -crv libhello.a hello.o  // 需通过（ar/lib.exe）工具将目标文件打包成.a静态库文件

动态链接库  // 动态库在程序编译时并不会被链接到目标代码中，而是在程序运行是才被载入，不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，动态库也称为共享库
后缀名:
linux .so 
windows .dll
优点：
节约空间和资源
方便更新迭代，可增量更新
缺点：
不方便移植
linux创建动态库：  // 不需要打包工具（ar/lib.exe），直接使用编译器即可创建动态库
gcc -fPIC -c hello.c  // 先生成目标文件，-fPIC，创建与地址无关的编译程序（pic，position independent code），为了能够在多个应用程序间共享
gcc -shared -o libhello.so hello.o  // 生成动态库，-shared，指定生成动态链接库
linux使用动态库：
gcc test.c -L../DynamicLibrary -lhello  // 引用动态库编译生成可执行文件的方法跟静态库一样，代码中需引用库的头文件。注意，linux动态库默认存放位置为/lib、/usr/lib，如果某动态库不在系统默认目录中，需要在系统中注册该动态库（ldconfig），否则编译器会找不到该动态库

进程是操作系统资源分配的最小单元。操作系统分配给进程的内存空间中包含五种段：
数据段  // 存放程序中的静态变量和已初始化且不为零的全局变量
代码段  // 存放可执行文件的操作指令，代码段是只读的，不可进行写操作。这部分的区域在运行前已知其大小
bss  // block started by symbol，存放未初始化的全局变量，在变量使用前由运行时初始化为零
堆  // 存放进程运行中被动态分配的内存，其大小不固定
栈  // 存放程序中的临时的局部变量和函数的参数值

逻辑地址  // 与当前数据在内存中的物理分配地址无关的访问地址，在执行对内存的访问之前必须转化为物理地址
物理地址  // 数据在内存中的实际位置

主要内存管理手段
分页
分段

内存单元的大小单位
位  // 1bit
字节  // 8bit
字  // 一般32bit，具体多少bit依赖于平台和编译器

内存单元编址以字节位单位，即固定8bit
目前，普通的计算机，内存位宽（内存一次能传输的数据量）、cpu位宽，一般都是32bit或64bit

有符号整数类型  // 整数默认是有符号整数，c语言标准只定义了整数类型最小的存储空间，short至少占2字节，long至少占4字节，long long至少占8字节。目前，个人计算机最常见的配置，short 2字节，int 4字节，long 4字节，long long 8字节。c语言标准并未定义有符号类型的溢出规则
signed char
int  // 等价于signed、signed int
short  // 等价于short int、signed short、signed short int
long  // 等价于long int、signed long、signed long int
long long  // c99，等价于long long int、signed long long、signed long long int

无符号整数类型
_Bool  // bool，在stdbool.h头文件中定义
unsigned char
unsigned int   // 等价于unsigned
unsigned short   // 等价于unsigned short int
unsigned long  // 等价于unsigned long int
unsigned long long  // c99，等价于unsigned long long int

字符类型  // char类型，也叫字节类型，即分配一个字节的类型，其实是一个标准的整数类型。单独的char这个单词究竟是代表signed char还是unsigned char，取决于编译器，因此最好在程序中显式的定义
'\0' -> 0
' ' -> 32
'0' -> 48
'a' -> 97
'A' -> 65

字符本质上是一个整数，字符串本质上是一个将每个字符（整数）按照某种编码方式进行编码，然后组合而成的字节序列
\u****，unicode码点，十六进制编码，代表一个字符
\x**，十六进制编码的数据，不特指某种编码方式，可代表多种编码方式，如：utf-8、ascii等。用不同的解码方式对同一段字节序列解码，会得到不同的结果，因此，在解码前需知道该字节序列的编码方式

浮点类型  // 计算机中的所有的浮点数都是有符号的
float  // 4字节
double  // 8字节
long double  // c99，对long double的处理，取决于编译器，8字节、10字节、12字节、16字节都有可能

移位运算符
<<  // 把值左移，右边空出的用0填补
>>  // 对unsigned类型的无符号值右移时，左边空出的用0填补。对signed类型的有符号值右移时，取决于编译器，有些用符号位填补（算术移位），有些用0填补（逻辑移位）

枚举类型  // enum，一种由用户在程序中定义的整数类型

void类型  // 未确定类型或任何类型，表示“没有值可以获得”

编译预处理
伪指令或预处理指令  // 以#号开头，#号后面是指令关键字，#号与指令关键字之间允许存在任意个数的空白字符。同常规的代码行不同，预处理指令行不能用分号作为结束符
常见的预处理指令主要有四类：
1、包含头文件
#include <xxx.h>  // 告诉预处理程序在编译器自带的或外部库的头文件中搜索被包含的头文件
#include "xxx.h"  // 告诉预处理程序在当前被编译的应用程序的源代码文件中搜索被包含的头文件，如果找不到，再搜索编译器自带的头文件
2、宏定义和宏展开
#define  // 宏定义
  宏定义中的，#运算符，把跟在其后的参数转换成一个字符串，如：#define HELLO(x) "hello, "#x，HELLO(world) => "hello, world"，注意，world并非变量，只是单纯的当作文本使用
  宏定义中的，##运算符，由于把参数连接到一起，如：#define NUM(x) x##x##x，NUM(a) => aaa，注意，a并非变量，只是单纯的当作文本使用，但预编译后生成的aaa是变量
#undef  // 取消宏定义  
3、条件编译
#if  // 该指令后面跟常量表达式
#elif
#else
#ifdef  // 等价于#if defined
#ifndef  // 等价于#if !defined
#endif
4、特殊符号处理
#error  // 使编译器显示一条错误消息，然后停止编译
#line  // 改变__LINE__与__FILE__的内容 
#pragma  // 没有正式的定义，编译器可以自定义用途，典型的用途是禁止或允许某些警告信息
__FILE__  // 当前程序文件名
__LINE__  // 当前行号
__DATE__  // 当前日期，长整数
__TIME__  // 当前时间，长整数
__STDC__  // 如果编译器遵循ANSI C标准，那么它就是一个非0值

c语言不可以在函数内部再定义函数

默认情况下，外部变量和静态变量被初始化为0，未经显式初始化的自动变量的值为未定义值（即无效值）

static声明的外部变量和函数，它们的作用域限定为被编译源文件的剩余部分，之前的部分，即使使用extern也无法访问
static声明的局部变量是一种只能在某个特定函数中使用但一直占据存储空间的变量

const static == static const
const限定符指定变量的值不能被修改，它本身是类型系统的一部分，类型匹配时需带上
const int *ptr = &x;  // 常量指针，ptr本身可变，但指向的内容不可变
int * const ptr = &x;  // 常量指针变量（变量的常量指针），ptr本身不可变，但指向的内容可变
const int * const ptr = &x;  // 指针常量（常量的常量指针），ptr本身不可变，指向的内容也不可变

register声明寄存器变量，只适用于自动变量以及函数的形式参数

根据定义，数组类型的变量或表达式的值是该数组第0个元素的地址，即arr实质上是&arr[0]
ptr = arr 等价于 ptr = &arr[0]  // ptr，指针变量名，一般情况下，用指针编写的程序比用数组下标编写的程序执行速度快。在计算数组元素arr[i]的值时，c语言实际上先将其转换为*(arr+i)的形式，然后再进行求值
&arr[i] 等价于 ptr + i
arr[i] 等价于 *(ptr + i)
数组名和指针之间有一个不同之处。指针是一个变量，因此，ptr = arr，ptr++都是合法的，但数组名不是变量，因此，arr = ptr，arr++都是非法的，但是arr + 1是合法的，因为并没有赋值
在函数定义中，形式参数char *arr等价于char arr[]，推荐使用前者，因为它更直观的表明该参数实质上是一个指针

*p++  // 先取值，后指针++
*++p  // 先指针++，后取值
++*p  // 先取值，后值++
(*p)++  // 先取值，后值++

数组指针  // int (*p)[10]，指向数组的指针，主要用于指向二维数组的某一行
int a[10];
int (*p)[10] = &a;  // 注意，不可以int (*p)[10] = a;，因为，类型不匹配，a本质上是&a[0]，而p的类型是一个指向一维数组的指针（实际上是二级指针），该数组一定且只包含十个整型
int *p = a;  // 正确，p存放的a数组第一个元素的地址
int b[2][2] = {{1, 2}, {3, 4}};  // b是一个二维数组
int (*p1)[2] = b;  // 正确，p1存放的b数组第一个元素（{1, 2}而不是1）的地址，即数组指针，指向二维数组的第一行
指针数组  // int *p[10]，元素是指针的数组，一般情况下指针会指向动态分配的内存区域

一级指针（指向普通变量），二级指针（指向一级指针），三级指针（指向二级指针），多级指针。多级指针常与多维数组一起使用

通过指针可创建动态数组

指针，一种存放变量地址的变量，通常占用2或4个字节
c语言中，默认都是值传递，复制并新建内存，想共享内存只能通过指针
指针分为栈指针（使用时要小心，容易出现悬空指针、野指针）和堆指针
引用，其实就是别名，和指针类似，只是编译器帮忙做了自动取地址和自动解引用的操作，而且限定了不能修改。标准的c语言不支持引用，但c++支持
ANSI C使用类型void*代替char*作为通用指针的类型
对指针有意义的初始化值只能是0或者是表示地址的表达式，c语言保证，0永远不是有效的数据地址，因此，当指针的值为0时表示发生了异常事件
指针与整数类型之间不能相互转换，0是唯一的例外，常量0可以赋值给指针，指针也可以和常量0比较
程序中经常使用符号常量NULL代替0，NULL定义在标准头文件<stddef.h>中
在某些情况下，可以对指针进行比较运算，例如，对指向同一数组的两个指针进行比较，c语言对指向不同数组的两个指针之间的算术或比较运算没有定义
所有的指针运算都会自动考虑它所指向对象的长度，根据指向对象的长度按比例缩放

空指针，NULL，值为0，不指向任何空间，所以不能使用间接运算符*取值
野指针，wild pointer，没有被初始化过的指针或者被错误初始化的指针，即地址为非法值
悬空指针，dangling pointer，指针最初指向的内存已经被释放了的一种指针
void指针，指向void的指针，万能指针，表示未确定类型的指针，void指针指向一块内存，却没有告诉程序该如何解释这块内存，因此，不能直接用该类型的指针获取所指向内存的内容，必须先转换成具体类型的指针才行

typedef

sizeof 对象名  // 也可以sizeof(对象名)，返回占用存储空间字节数，类型size_t，该类型在头文件<stddef.h>中定义，实质上是无符号整型数
sizeof(类型名)

c语言堆内存操作接口
void *malloc(size_t size);  // 申请size个字节的堆内存，将首地址返回，失败返回NULL
void *calloc(size_t nmemb, size_t size);  // 申请nmemb个单元，每个单元size个字节
void *realloc(void *ptr, size_t size);  // 改变原来申请的空间的大小，将首地址返回
void free(void *ptr);  // 释放堆内存

c99标准
int main(void) {}
int main(int argc, char *argv[]) {}  // argc（argument count），命令行参数的个数，argv（argument vector），一个字符串数组，也可以写为char **argv

main函数，一般来说，返回值为0表示正常终止，返回值为非0表示出现异常情况或出错结束条件。c语言中，函数的参数、返回值默认都为int类型

结构体
struct coord {
    int x;
    int y;
};
定义时初始化
struct coord abc = {1,2};
struct coord abc = {.x=1, .y=2};  // c99，c11新增标准

内存对齐  // 处理器一般不是按字节来存取内存，而是以2字节、4字节、8字节甚至32字节为单位来存取内存
1、struct或union的成员，第一个成员在偏移0的位置，之后每个成员的起始位置必须是该成员（正在排放的成员）大小的整数倍
2、如果结构体A含有结构体成员B，那么B的起始位置必须是B中最大成员大小的整数倍地址
3、结构体的总大小，必须是内部最大成员的整数倍
4、如果结构体中的某成员是数组，那么参与计算的是该数组中所存放的元素
显式指定对齐方式，c语言提供了两种显式指定对齐方式的方法
1、#pragma pack(n)  // 设置全局对齐方式，结构体和结构体内部成员都将遵循设置的对齐，原则是，成员自身对齐值（成员size）和指定对齐值（n）中的较小者
#pragma pack (8)  // 指定按照8字节对齐，目前cpu主流cache_line长度为8字节
struct test {
  char a;
  int b;
  short c;
};
#pragma pack ()  // 取消指定对齐，恢复默认对齐
2、__attribute__ ((aligned(n)))  // 修饰结构体，该结构体遵循该对齐参数，但该结构体内部成员依旧遵循默认的对齐参数（成员自身对齐值）
struct test {
  char a;
  int b;
  short c;
} __attribute__ ((aligned(8)));

ptr->a 等价于 (*ptr).a  // 括号不可以省略
entity.a 等价于 (&entity)->a  // 括号不可以省略

联合  // union，又称共用体，一般编程中用的较少，在单片机中用的较多

位字段  // 结构体、联合的成员可以是位字段，单位bit，位字段是一个由具有特定数量位组成的整型变量，如果连续声明多个小的位字段，编译器会将它们合并为一个机器字
与结构中的其它成员不同，位字段通常不会占据可寻址的的内存位置（因为分配地址的基本单位是字节），因此无法对位字段采用地址运算符&，也不能对位字段进行位运算

文件
从用户角度，分为普通文件和设备文件（指与主机相连的各种外部设备，如显示器、键盘等，在操作系统中，把外部设备看作一个文件来管理。如显示器定义为标准输出文件，键盘定义为标准输入文件）
从文件的编码方式上，分为文本文件和二进制文件

标准输入输出函数
scanf
printf
getchar
putchar
gets
puts

文件指针  // FILE *file;FILE类型是一个结构体，定义在stdio.h中
文件位置指针  // 文件中有一个位置指针，用于指向当前文件的读写位置
标准设备文件是由操作系统控制的，由系统自动打开或关闭，c语言提供了3个标准设备文件的文件指针，stdin、stdout、stderr，定义在stdio.h中

文件打开
FILE *fopen(const char *path, const char *mode);  // 文件不存在时，返回NULL

文件关闭
int fclose(FILE *fp);  // 关闭成功返回NULL，关闭失败返回非NULL值

文件顺序读写
字符读写函数  // 适用于读写较小的文件
int fgetc(FILE *fp);  // 从文件中读取一个字符，正常时返回读取字符的ascii码值，异常时返回EOF（-1）
int fputc(int ch, FILE *fp);  // 写一个字符到文件中，正常时返回读取字符的ascii码值，异常时返回EOF（-1）
字符串读写函数  // 适用于读写较小的文件
char *fgets(char *str, n, FILE *fp);  // 从文件中读取n-1个字符，存储到str所指向的内存中，最后加上结束'\0'，正常时返回字符串str的内存首地址，异常时返回NULL
int fputs(char *str, FILE *fp);  // 将字符串str写入到文件中，正常时返回写入文件的字符个数，即字符串长度，异常时返回NULL
格式化读写函数  // 适用于读写较小的文件
int fscanf(FILE *fp, char *format, [arguments...]);  // 成功时，返回成功读入参数的个数，失败时返回EOF（-1）
int fprintf(FILE *fp, char *format, [arguments...]);  // 成功时，返回写入文件的字符个数，失败时返回一个负值
数据块读写函数 
int fread(void *buffer, unsigned size, unsigned count, FILE *fp);  // 按二进制形式，将size*count个字节读到buffer中，成功时，返回数据块的数量，出错时，返回0
int fwrite(void *buffer, unsigned size, unsigned count, FILE *fp);  // 按二进制形式，将size*count个字节写入，从buffer中读出然后写入到文件中，成功时，返回数据块的数量，出错时，返回0

文件随机读写  // 移动文件位置指针后，可以用任意一种读写函数进行读写
符号常量
SEEK_SET 0  // 文件首
SEEK_CUR 1  // 当前位置
SEEK_END 2  // 文件末尾 
文件定位  // 按要求移动文件位置指针
void rewind(FILE *fp);  // 将文件位置指针宠重新指向文件的首部
int fseek(FILE *fp, long offset, int base);  // 将文件位置指针移到基于base的相对位置offset（以字节为单位）处，正常时返回当前文件位置指针的位置，异常时返回-1，一般用于二进制文件，在文本文件中由于要进行转换，往往计算的位置会出现错误
long ftell(FILE *fp);  // 获取文件位置指针的当前读写位置，正常时返回位移量（以字节为单位），异常时返回-1

文件检测函数
检测文件是否结束
int feof(FILE *fp);  // 如果文件结束返回1，否则返回0
检测读写文件时是否出错
int ferror(FILE *fp);  // 如果读写时没有出现错误，返回0，否则返回非0
重置文件结束标志和文件出错标志
void clearerr(FILE *fp);  // 将文件结束标志和出错标志重置为0

其它文件操作函数
create  // 创建文件，io.h
remove  // 删除文件，stdio.h
searchpath  // 查找文件，dir.h

windows下控制台应用程序中文乱码解决方案
打开命令提示符窗口，执行命令chcp 65001，修改命令提示符的解码方式。65001指UTF-8

23种设计模式
1、单例模式  // singleton。用于构造单实例对象
2、工厂模式  // factory method。用于动态生成对象。使由子类决定实例化哪一个类，工厂方法使得子类实例化的过程推迟
3、抽象工厂模式  // abstract factory。用于生成一系列的对象。用于创建一系列相关或相互依赖的对象
4、创建者模式  // builder。用于构造复杂对象
5、原型模式  // prototype。用于克隆对象
6、适配器模式  // adapter。用于转换接口，使得原本不兼容的接口得以协同工作
7、装饰器模式  // decorator。用于动态的给一个对象添加一些额外的职责
8、代理模式  // proxy。为其它对象提供一种代理以控制这个对象的访问
9、外观模式  // facade。用于对外统一接口
10、桥接模式  // bridge。用于继承树拆分。将抽象部分和实现部分分离开来，使得它们可以独立扩展
11、组合模式  // composite。用于树形目录结构。将对象组合成树形结构以表示”整体-部分“的层次结构，使得用户对单个对象和组合对象的访问具有一致性
12、享元模式  // flyweight。提供支持大量细粒度对象共享的有效方法，如字符串共享
13、策略模式  // strategy。通过直接更换算法对象的方式实现多元算法
14、模板方法模式  // template method。通过对同一模板结构的继承和不同实现来实现多元算法，把通用步骤和通用方法放到父类中，把具体实现延迟到子类中实现，使得实现符合开闭原则
15、观察者模式  // observer
16、迭代器模式  // iterator
17、责任链模式  // chain of responsibility。将所有接收对象链接起来，在链中传递请求，直到有一个对象处理该请求
18、命令模式  // command。本质是把某个对象的方法调用封装到另一个对象中，方便传递、存储、调用。可用于增加配置灵活性、批处理、任务队列、撤销等
19、备忘录模式  // memento。在一个对象之外保存该对象的内部状态，从而可以在后面的某时间点恢复该对象的状态
20、状态模式  // state。允许一个对象，在内部状态改变时，改变它的行为
21、访问者模式  // visitor。不同的访问者访问同一对象得到不同的结果
22、中介者模式  // mediator。用一个中介对象来封装一系列的对象交互，它使得各对象不需要显式的相互调用，从而达到低耦合
23、解释器模式  // interpreter

简单工厂  // 不暴露创建对象的细节，直接在该具体工厂类中通过传参的方式选择并生成某种类型的对象。一个具体工厂类返回一个代表多种类型对象的接口
工厂方法  // 使用子类的方式延迟生成对象在子类中实现，通过第三方方法灵活的传入具体的工厂类执行统一的创建和执行过程。多种具体工厂类对应一个工厂类接口，多种类型对象对应一个对象接口
抽象工厂  // 用于生成一系列相关或相互依赖的对象，如果抽象工厂退化成生成的对象无关联则成为工厂函数模式。一个抽象工厂接口定义多个方法，每个方法构建不同类型但又也具有一定关系的对象（返回接口），通过第三方方法灵活的传入具体的工厂类，执行多个对象统一的创建和执行过程

常用算法
分治法  // 把一个问题拆分成多个小规模的相同子问题，一般用递归实现
回溯法  // 用于求一个问题的所有解或任一解。一种选优搜索算法，按选优条件向前搜索，以达到目标，当搜索到某一步时，原先的选择并不优或者达不到目标，就退回一步重新选择
贪心法  // 用于求满意解。所做的每一步有明确、既定的策略，每一步都是当前步骤的局部最优解，但从整体上来说不一定是最优解
动态规划  // 用于求最优解。划分子问题，并把子问题的结果用一个数组存储，利用查询子问题的结果，构造出最终问题的结果。对于每一步决策，列出所有可能的局部解（用一个数组存起来），然后依据某个判定条件，舍弃那些肯定不能得到整体最优解的局部解，从而，最后可得到整体最优解

时间复杂度
O(1) < O(log2 n) < O(n) < O(nlog2 n) < O(n^2) < O(n^3) < O(2^n)
1  // 顺序结构
n  // 单层循环
n^2  // 两层循环
log2 n  // 树形结构