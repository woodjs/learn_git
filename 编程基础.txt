23种设计模式可分为3大类：
创建型（creational）模式：如何创建对象，1-5
结构型（structural）模式：如何实现类或对象的组合，获得更大的结构，6-12
行为型（behavioral）模式：类或对象怎样交互以及怎样分配职责，13-23

23种设计模式 
1、单例模式  // singleton。保证一个类仅有一个实例，并提供一个可以访问它的全局访问点
   - 简单工厂模式  // 通过专门定义一个工厂类来负责创建其它类的实例，被创建的实例通用都具有共同的父类（或接口）。不属于gof（gang of four） 23种设计模式，但也是一种常见的设计模式
2、工厂方法模式  // factory method。定义一个创建目标对象的工厂类接口，多种具体工厂类对应一个工厂类接口，多种类型的目标对象对应一个目标对象接口。通过灵活的传入具体的工厂类执行统一的创建和执行过程，将实际的目标对象创建工作推迟到子类中
3、抽象工厂模式  // abstract factory。工厂方法模式的升级版（产品族、产品等级）。提供一个创建一系列相关或相互依赖的对象的工厂类接口，一个工厂类接口定义多个方法，每个方法构建不同类型但又也具有一定关系的对象（返回接口），如果抽象工厂退化成生成的对象无关联则成为工厂函数模式
4、创建者模式  // builder。将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示
5、原型模式  // prototype。用原型实例指定创建对象的种类，并且通过拷贝原型创建新的对象
6、适配器模式  // adapter。将一个类的接口转换成另外一个接口，使得原本由于接口不兼容而不能一起工作的类可以一起工作
7、装饰器模式  // decorator。动态给一个对象添加一些额外的职责。就增加功能来说，此模式比生成子类更加灵活。和代理模式很像，但比代理模式灵活，装饰器模式无状态可任意叠加
8、代理模式  // proxy。为其它对象提供一种代理以控制对这个对象的访问，通过代理对象可以添加其它操作
9、外观模式  // facade。为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得子系统更加容易使用
10、桥接模式  // bridge。用于继承树拆分。将抽象部分和实现部分分离，使得它们都可以独立的变化
11、组合模式  // composite。将对象组合成树形结构以表示“整体-部分”的层次结构，使得用户对单个对象和组合对象的使用具有一致性
12、享元模式  // flyweight。已共享的方式高效的支持大量细粒度的对象。如字符串共享
13、策略模式  // strategy。通过直接更换算法对象的方式实现多元算法
14、模板方法模式  // template method。通过对同一模板结构的继承和不同实现来实现多元算法，把通用步骤和通用方法放到父类中，把具体实现延迟到子类中实现，使得实现符合开闭原则
15、观察者模式  // observer。定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新
16、迭代器模式  // iterator。提供一种方法顺序来访问聚合对象中的各个元素，而又不需要暴露改对象的内部表示
17、责任链模式  // chain of responsibility。将所有接收对象链接起来，在链中传递请求，直到有一个对象处理该请求
18、命令模式  // command。可以将请求发送者和接受者完全解耦，发送者和接受者之间没有直接引用关系，发送者只需知道如何发送请求（命令对象），而不必知道如何完成请求。本质是通过传递请求（命令对象）实现调用接收者的功能，方便传递、批处理（批量传递命令）等
19、备忘录模式  // memento。在一个对象之外保存该对象的内部状态，从而可以在后面的某时间点恢复该对象的状态
20、状态模式  // state。对象的行为，依赖于它所处的状态
21、访问者模式  // visitor。不同的访问者访问同一对象得到不同的结果
22、中介者模式  // mediator。用一个中介对象来封装一系列的对象交互，它使得各对象不需要显式的相互调用，从而达到低耦合
23、解释器模式  // interpreter。如何为简单的语言定义一个语法，如何在该语言中表示一个句子，以及如何解释这些句子

观察者模式和发布订阅模式区别
观察者模式里，只有两个角色观察者和被观察者，被观察者直接调度观察者，观察者和被观察者是松耦合的关系。而发布订阅模式里，不仅仅有发布者和订阅者两个角色，还有一个经常被我们忽略的角色经纪人（Broker），由broker调度订阅者，发布者和订阅者不存在耦合
观察者模式，多用于单个应用内部。发布订阅模式，则更多的是一种跨应用的模式(cross-application pattern)，比如我们常用的消息中间件

面向对象设计7大原则 // 核心思想，高内聚低耦合
单一职责原则 // 类的职责单一，对外只提供一种功能，而引起类变化的原因都应该只有一个
开闭原则 // 类的改动是通过增加代码进行的，而不是修改源代码
里氏替换原则 // 任何抽象类（接口）出现的地方，都可以用它的实现类进行替换，实际就是虚拟机制，语言级别实现面向对象功能
依赖倒转原则 // 依赖于抽象（接口），不要依赖具体的实现（类），也就是针对接口编程
接口隔离原则 // 不应该强迫用户程序依赖它们不需要的接口方法。一个接口应该只提供一种对外功能，不应该把所有操作都封装到一个接口中去
组合复用原则 // 如果使用继承会导致父类的任何变换都可能影响子类的行为。如果使用对象组合，就降低了这种依赖关系。对于继承和组合，优先使用组合
迪米特法则 // 一个对象应当对其它对象尽可能少的了解，从而降低各个对象之间的耦合，提高系统的可维护性

六大算法范式
暴力破解法
分治法  // 把一个问题拆分成多个小规模的相同子问题，一般用递归实现
回溯法  // 用于求一个问题的所有解或任一解。一种选优搜索算法，按选优条件向前搜索，以达到目标，当搜索到某一步时，原先的选择并不优或者达不到目标，就退回一步重新选择。一般以深度优先的方式搜索树
分支限界法  // 与回溯法类似， 回溯法的求解目标是找出树中满足约束条件的所有解，而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即在某种意义下的最优解。一般以广度优先或最小耗费优先搜索队列的方式搜索
贪心算法  // 用于求满意解。所做的每一步有明确、既定的策略，每一步都是当前步骤的局部最优解，但从整体上来说不一定是最优解
动态规划法  // 用于求最优解。划分子问题，并把子问题的结果用一个数组存储，利用查询子问题的结果，构造出最终问题的结果。对于每一步决策，列出所有可能的局部解（用一个数组存起来），然后依据某个判定条件，舍弃那些肯定不能得到整体最优解的局部解，从而，最后可得到整体最优解

树  // 前序遍历、中序遍历、后序遍历
满二叉树
完全二叉树
非完全二叉树
线索二叉树
查找二叉树
平衡二叉树
最优二叉树  // 哈夫曼树（通过使用不等长的编码来表示不同符号，出现频率越高的符号编码越短，以便更有效地压缩数据）、哈夫曼编码（左分支边为0，右分支边为1）

图  // 深度优先遍历、广度优先遍历。存储方式：邻接矩阵（适合边多的情况）、邻接链表
无向图  // 连通图（无向图任意两个顶点之间都是连通的，则称为连通图）、连通分量（无向图的极大连通子图称为其连通分量）
有向图  // 强连通图、强连通分量。弧，带方向的边
完全图  // 节点两两之间都有连线
网  // 边带权值的图
最小生成树  // 图中的树，边的权值之和最小。普里姆算法（顶点相关，O(n^2)，适合边稠密的网）、克鲁斯卡尔算法（边相关，O(eloge)，适合边稀疏的网）
稠密图  // 边多
稀疏图
拓扑序列  // 用于找出有向图的执行序列，避免资源依赖的问题，优先执行入度为0的节点，类似进程中的前趋图原理

时间复杂度
O(1) < O(log2 n) < O(n) < O(nlog2 n) < O(n^2) < O(n^3) < O(2^n)
1  // 顺序结构
n  // 单层循环
n^2  // 两层循环
log2 n  // 树形结构