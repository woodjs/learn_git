23种设计模式可分为3大类：
创建型（creational）模式：如何创建对象，1-5
结构型（structural）模式：如何实现类或对象的组合，
行为型（behavioral）模式：类或对象怎样交互以及怎样分配职责

23种设计模式 
1、单例模式  // singleton。保证一个类仅有一个实例，并提供一个可以访问它的全局访问点
   - 简单工厂模式  // 通过专门定义一个工厂类来负责创建其它类的实例，被创建的实例通用都具有共同的父类（或接口）。不属于gof（gang of four） 23种设计模式，但也是一种常见的设计模式
2、工厂方法模式  // factory method。定义一个创建目标对象的工厂类接口，多种具体工厂类对应一个工厂类接口，多种类型的目标对象对应一个目标对象接口。通过灵活的传入具体的工厂类执行统一的创建和执行过程，将实际的目标对象创建工作推迟到子类中
3、抽象工厂模式  // abstract factory。工厂方法模式的升级版。提供一个创建一系列相关或相互依赖的对象的工厂类接口，一个工厂类接口定义多个方法，每个方法构建不同类型但又也具有一定关系的对象（返回接口），如果抽象工厂退化成生成的对象无关联则成为工厂函数模式
4、创建者模式  // builder。将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示
5、原型模式  // prototype。用原型实例指定创建对象的种类，并且通过拷贝原型创建新的对象
6、适配器模式  // adapter。用于转换接口，使得原本不兼容的接口得以协同工作
7、装饰器模式  // decorator。用于动态的给一个对象添加一些额外的职责
8、代理模式  // proxy。为其它对象提供一种代理以控制这个对象的访问
9、外观模式  // facade。用于对外统一接口
10、桥接模式  // bridge。用于继承树拆分。将抽象部分和实现部分分离开来，使得它们可以独立扩展
11、组合模式  // composite。用于树形目录结构。将对象组合成树形结构以表示”整体-部分“的层次结构，使得用户对单个对象和组合对象的访问具有一致性
12、享元模式  // flyweight。提供支持大量细粒度对象共享的有效方法，如字符串共享
13、策略模式  // strategy。通过直接更换算法对象的方式实现多元算法
14、模板方法模式  // template method。通过对同一模板结构的继承和不同实现来实现多元算法，把通用步骤和通用方法放到父类中，把具体实现延迟到子类中实现，使得实现符合开闭原则
15、观察者模式  // observer
16、迭代器模式  // iterator
17、责任链模式  // chain of responsibility。将所有接收对象链接起来，在链中传递请求，直到有一个对象处理该请求
18、命令模式  // command。本质是把某个对象的方法调用封装到另一个对象中，方便传递、存储、调用。可用于增加配置灵活性、批处理、任务队列、撤销等
19、备忘录模式  // memento。在一个对象之外保存该对象的内部状态，从而可以在后面的某时间点恢复该对象的状态
20、状态模式  // state。允许一个对象，在内部状态改变时，改变它的行为
21、访问者模式  // visitor。不同的访问者访问同一对象得到不同的结果
22、中介者模式  // mediator。用一个中介对象来封装一系列的对象交互，它使得各对象不需要显式的相互调用，从而达到低耦合
23、解释器模式  // interpreter

面向对象设计7大原则 // 核心思想，高内聚低耦合
单一职责原则 // 类的职责单一，对外只提供一种功能，而引起类变化的原因都应该只有一个
开闭原则 // 类的改动是通过增加代码进行的，而不是修改源代码
里氏替换原则 // 任何抽象类（接口）出现的地方，都可以用它的实现类进行替换，实际就是虚拟机制，语言级别实现面向对象功能
依赖倒转原则 // 依赖于抽象（接口），不要依赖具体的实现（类），也就是针对接口编程
接口隔离原则 // 不应该强迫用户程序依赖它们不需要的接口方法。一个接口应该只提供一种对外功能，不应该把所有操作都封装到一个接口中去
组合复用原则 // 如果使用继承会导致父类的任何变换都可能影响子类的行为。如果使用对象组合，就降低了这种依赖关系。对于继承和组合，优先使用组合
迪米特法则 // 一个对象应当对其它对象尽可能少的了解，从而降低各个对象之间的耦合，提高系统的可维护性

六大算法范式
暴力破解法
分治法  // 把一个问题拆分成多个小规模的相同子问题，一般用递归实现
回溯法  // 用于求一个问题的所有解或任一解。一种选优搜索算法，按选优条件向前搜索，以达到目标，当搜索到某一步时，原先的选择并不优或者达不到目标，就退回一步重新选择。一般以深度优先的方式搜索树
分支限界法  // 与回溯法类似， 回溯法的求解目标是找出树中满足约束条件的所有解，而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即在某种意义下的最优解。一般以广度优先或最小耗费优先搜索队列的方式搜索
贪心算法  // 用于求满意解。所做的每一步有明确、既定的策略，每一步都是当前步骤的局部最优解，但从整体上来说不一定是最优解
动态规划法  // 用于求最优解。划分子问题，并把子问题的结果用一个数组存储，利用查询子问题的结果，构造出最终问题的结果。对于每一步决策，列出所有可能的局部解（用一个数组存起来），然后依据某个判定条件，舍弃那些肯定不能得到整体最优解的局部解，从而，最后可得到整体最优解

时间复杂度
O(1) < O(log2 n) < O(n) < O(nlog2 n) < O(n^2) < O(n^3) < O(2^n)
1  // 顺序结构
n  // 单层循环
n^2  // 两层循环
log2 n  // 树形结构