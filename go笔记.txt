传值还是传指针？只有明确需要传指针的时候才传指针，否则一律传值
需要传指针的情况，包括但不限于：
1、结构体很大，传指针减少复制开销
2、需要对结构体进行修改
3、结构体对象复制会导致功能失效，因此，不能复制，如：锁
4、参数可能是空值，传指针便于判断是否为nil
...

go数据类型四大类
基础类型  // number，string，bool
聚合类型  // array，struct
引用类型  // pointer，slice，map，function，channel
接口类型  // interface

基本数据类型
uintptr  // 无符号整型，存放指针 
int  // 虽然大小就是32位，但是和int32还是不同类型，需显示转换
int8、int16、int32、int64
uint8、uint16、uint32、uint64
rune  // 符文，int32别名，常用来处理unicode或utf-8字符
byte  // uint8别名，常用来处理ascii字符
float32 
float64
complex64  // 复数
complex128  
bool
string  // 字符串是不可变的字节序列，中文字符在unicode下占2个字节，在utf-8编码下占3个字节，go语言默认编码是utf-8

const
iota  // 中文，微量，go语言的常量计数器，只能在常量的表达式中使用，iota不是类型。iota在const关键字出现时将被重置为0（const内部的第一行之前），const中每新增一行常量声明将使iota计数一次
nil  // 中文，零

复合数据类型
数组  // var a [3]int = [3]int{1,2,3}，通过range遍历数组，数组长度是数组类型的一部分
slice  // 拥有相同类型元素的可变长度序列。属性包括指针、长度、容量，[]string，make([]T, len)，make([]T, len, cap)，make([]T, cap)[:len] 
map  // 散列表，拥有键值对元素的无序集合，a := make(map[string][int]){"key1": 1,}，key必须可以比较，除了slice、map、function的内建类型都可以作为key，struct不包括上述类型也可以作为key
结构体  // 将零个或多个任意类型的变量组合到一起的聚合数据类型

函数  // 函数类型的零值是nil，go语言中函数没有重载只有重写，go语言的所有函数都是值传递，没有引用传递
声明  // func name(paramerter-list) (result-list) {}
多返回值  // error放在返回参数列表的最后，error为空时返回零值nil
匿名函数  // 匿名函数只能在函数级别的作用域进行声明，闭包
变长函数  // 参数数量不固定，func sum(vals ...int) int {}
延迟调用函数  // defer

函数传递slice，map等引用类型时，可通过变量修改内部存放的值，但不能修改引用本身，该引用不能像指针那样被解引用（*）

方法
对于使用指针接收者的方法，用一个指针或者一个可取得地址的值来调用都是合法的。但接口类型中存储的具体值（Concrete Value）并不能取到地址，因此不能通过一个存储非指针的接口，调用一个接收者为指针的方法

常用语言级函数
总的来讲，new的作用是初始化一个指向类型的指针(*T)，make的作用是为slice，map或chan初始化并返回引用(T)
new  // 给一个值类型的数据分配内存，调用成功后返回一个初始化的内存块指针，同时该类型被初始化为零值。分配的内存不一定放在堆上，也有可能在栈上，由编译器决定。 不同于其他语言中new所做的工作，它只是将内存清零，而不是初始化内存。原型定义：func new(Type) *Type
make  // 给引用类型分配内存空间，比如：slice，map，chan等，make直接返回一个引用类型的对象，而不是一个内存空间的指针。原型定义：func make(Type,size IntegerType) Type，Type必须是引用类型
len
cap
append  // 往array，slice等追加元素，返回修改后的slice
copy  // 内容拷贝，主要是切片的拷贝
close  // close channel时，由发送方close 
delete  // 删除散列表map的元素
real  // 返回complex的实部
imag  // 返回complex的虚部
panic  // 停止常规的goroutine
recover  // 恢复，用于定义goroutine panic时的动作，与defer关键字配合使用

结构体
结构体嵌套  

接口  // 一组仅包含方法名、参数、返回值的未具体实现的方法的集合。接口从概念上来讲是抽象的、不占空间的，但是，从类型系统上来讲是实际存在的类型，它类似一种结构体，内部包含动态类型和动态值
go语言中接口是隐式实现的，当结构体实现了某接口的所有方法，那么就认为该结构体实现了该接口
obj.(T)  // 类型断言，判断obj对象是否实现了某接口
空接口  // interface{}，空接口就是不包含任何方法的接口。因此，所有的类型都实现了空接口，空接口可以存储任意类型的数据
接口零值  // 接口的零值是nil
接口值  // 包括动态类型和动态值 
指针接口  // 某类型的指针类型实现了某接口，不代表该类型本身实现了某接口，因此调用时需通过指针调用
接口嵌套  

类型断言  
comma-ok断言  // if _, ok := obj.(int); ok {}，comma（逗号）
switch判断  // switch  value := obj.(type) { case int: }，type为关键字

go两种并发编程风格
goroutine和通道  // 通信顺序进程（communicating sequental process，csp）
共享内存多线程的传统模型

go语言中传统同步机制
WaitGroup
Mutex
Cond

当一个程序启动的时候，只有一个goroutine来调用main函数，称它为主goroutine，新的goroutine通过go语句进行创建
goroutine为非抢占式调度  // 当一个goroutine一直执行，不主动交出控制权，那么，其它任何goroutine都没有执行的机会。执行io操作，io操作内部会自动交出控制权、runtime.Gosched()可手动交出控制权

goroutine可能自动切换的点：
io
select
channel
等待锁
函数调用  // 有时
runtime.Gosched()  // 手动交出控制权

将一个数据value写入channel，这会导致阻塞，直到有其他goroutine从这个channel中读取数据
从channel中读取数据，如果channel之前没有写入数据，也会导致阻塞，直到channel中被写入数据为止
goroutine的通道默认是是阻塞的，可以通过加一个缓冲区来缓解阻塞  
make(chan int, 1)  // 有缓冲通道，解耦发送和接收
make(chan int)  // 无缓冲通道，又称为同步通道，即默认容量为0，提供发送和接收强同步保障
有缓冲通道和无缓冲通道，在接收值前，都必须先发送值，否则，会死锁。无缓冲通道，只有在有接收方的时候才能发送值，有缓冲通道无此限制
有缓冲通道，在不超过缓冲区大小时，不会出现发送方阻塞。无缓冲通道，只要channel数据没有被拿走，始终会阻塞发送方

单向通道类型  // 当一个通道用做函数的形参时，一般都定义为单向通道。在函数传参及任何赋值操作中将双向通道转换为单向通道是可以的，但反过来是不可以的
chan<- int  // 只能发送到通道，流出
<-chan int  // 只能从通道接收，流入

代码块结束时，关闭每一个通道并不是必需的。只有在通知接收方goroutine所有的数据都发送完毕时才需要关闭通道（因此，关闭通道可以作为一个广播机制）。因为，通道也可以通过垃圾回收器根据它是否可以访问来决定是否回收它，而不是只根据它是否关闭
不要将对channel的close操作和对文件的close混淆，代码块结束时，对每一个文件调用Close方法是非常重要的，因为文件属于程序外部资源

关闭后的通道特性： 
1、对一个关闭的通道再发送值就会导致panic
2、关闭一个已经关闭的通道会导致panic
3、对一个关闭的通道进行接收会一直获取值直到通道为空
4、对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值
5、i, ok := <-ch，通道关闭后再取值ok为false，可使用for i := range ch语法糖

goroutine泄漏
如果使用一个无缓冲通道，当某个goroutine发送数据到通道的时候，没有另一个goroutine来接收，该goroutine将被阻塞，且不能被回收，这个情况叫做goroutine泄漏，属于一个bug。不像回收变量，泄漏的goroutine不会自动回收，所有需确保goroutine在不需要的时候可以自动结束

无缓冲通道上如果发生了流入无流出，或者流出无流入，就会引起死锁
goroutine死锁处理方式
1、使goroutine无缓冲通道的流入和流出成对出现
2、创建缓冲通道

select语句  // 默认阻塞，可以通过default子句使程序非阻塞
go语言中select的功能与epoll(nginx)/poll/select的功能类似，都是监听io操作，当io操作发生的时候，触发相应的动作
如果有多个case都可以运行，select会随机公平地选出一个执行，其它不会执行
case后面必须是channel操作，否则报错
select中的default子句总是可运行的，所以没有default的select才会阻塞（死锁）
空select，也会引起阻塞（死锁）  // 加default
没有可运行的case，那么将会发生阻塞

select语句应用场景
timeout机制  // 超时判断
判断channel是否阻塞  // 或者说channel是否已经满了
退出机制  // 退出循环一定要用break+具体的标记，或者goto也可以，否则其实不是真的退出

defer关键字
defer用于资源的释放，会在函数返回之前进行调用，defer表达式可能会在设置函数返回值之后，在返回到调用函数之前，修改返回值
如果有多个defer表达式，调用顺序类似于栈，越后面的defer表达式越先被调用

反射  // 一种在编译时不知道类型的情况下，可更新变量、运行时查看值、调用方法以及直接对它们的内存布局进行操作的机制，go语言中只有interface类型才有反射一说
reflect.ValueOf()	// 动态获取输入参数接口中数据的值，如果为空则返回该类型的零值
reflect.TypeOf()  // 动态获取输入参数接口中值的类型，如果为空则返回nil 

runtime包
runtime.Gosched()  // 让出cpu时间片，gpm重新调度
runtime.Goexit()  // 立即退出当前goroutine，已注册的defer正常执行
runtime.GOMAXPROCS(n int)  // 设置当前程序并发时占用的cpu核心数（os线程），默认值是机器上的cpu核心数，最大256

包
go语言编译工具对源码目录有很严格的要求，每个工作空间（workspace）必须由bin（存放可执行文件）、pkg（存放编译好的库文件，主要是*.a文件）、src（存放源文件）三个目录组成
GOROOT  // 一个全局并且唯一的变量，用于指定存放Go语言本身的目录路径（安装路径）
GOPATH  // 一个工作空间的变量，它可以有很多个（用;号分隔），用于指定工作空间的目录路径，通常go get会使用第一个工作空间保存下载的第三方库（包），在开发时不管是哪一个工作空间下载的包都可以在任意工作空间使用
包名  // 类似命名空间（namespace），与包所在目录、文件名无关，目录名尽量不要使用保留名称，对于可执行文件必须包含package main以及入口函数main
go语言只有一种控制可见性的方式，定义的时候，首字母大写，可被包外访问，首字母小写，则仅包内成员可以访问
go语言中封装的单元是包，而不是类型。无论在函数内的代码，还是方法内，或者结构体内的字段对于同一个包中的所有代码都是可见的
包的导入  // import "相对目录/包主文件名"
import导入的参数是路径，而非包名   
在代码中引用包成员时，使用包名而非目录名  
尽管习惯将包名和目录名保证一致，但这不是强制规定
同一目录下，所有源文件必须使用相同的包名称
源文件名，没有限制，因为go语言中封装的单元是包
import   "crypto/rand"  // 默认模式: rand.Function
import R "crypto/rand"  // 包重命名: R.Function
import . "crypto/rand"  // 简便模式: Function
import _ "crypto/rand"  // 匿名导入: 仅让该包执行初始化函数
.
└── src
    └── test
        ├── main.go
        └── test2
            └── test.go
import "test/test2"  // 一般我们使用这种方式导入
import "./test2"  // 也可以使用相对目录，但这种方式导入的包仅对go run main.go有效
init函数  
当初始化包的时候，init函数也会被执行，它没有参数，也没有返回值，可以在一个文件或一个包中定义多个init函数。在同一个文件中，init函数是按照它们被定义的先后顺序被执行的
当所有的init函数被执行以后，main函数才会被执行。因此，init函数的主要工作就是，初始化无法在全局范围内初始化的全局变量，例如，初始化数组
go包管理  // go1.11+，项目不必放在GOPATH/src内
添加环境变量GO111MODULE为on或者auto  // auto（如果项目在$GOPATH/src里会使用$GOPATH/src的依赖包） | on（总是使用go.mod里require的包） | off
go.mod  // 包管理文件
go.sum  // 包含特定模块版本内容的预期加密哈希，不需要手工维护

扩展系统类型或第三方包类型，有两种方法：
定义类型别名
使用组合  // 结构体嵌套

常用命令
go run -race a.go  // 查看数据竞争
go doc  // 查看文档
godoc -http 6060  // 生成文档，可通过浏览器查看
go tool pprof ...  // 分析性能

性能分析工具
pprof  // 用于可视化和分析性能、分析数据的工具
pprof以profile.proto读取分析样本的集合，并生成报告以可视化并帮助分析数据（支持文本和图形报告）
