---
数值的进制
n进制转十进制  // 按权展开法
十进制转n进制  // 短除法，余数逆序表示。对于小数部分，使用短乘法，顺序表示
二进制、八进制、十六进制

计算机机器数的码制是由CPU（中央处理器）决定的
CPU是计算机的核心部件，负责执行指令、进行算术和逻辑运算等操作。CPU的体系结构和指令集架构决定了机器数的编码方式，包括数据的位数、符号位的位置等等。不同的CPU有不同的机器数码制，例如x86架构的CPU使用的是二进制补码的机器数码制。因此，机器数的码制是由CPU决定的

数值的码制  // 数值在计算机中有四种编码表示方式
原码  // 当整数进行乘除运算时，所有操作数都使用原码进行运算（由算法决定），得到结果后，再转为补码进行存储。+0：00000000，-0：10000000
反码  // 正数，不变。负数，所有位取反（不包括符号位）。+0：:00000000，-0：11111111
补码  // 正数，不变。负数，反码加1（包括符号位）。+0：:00000000，-0：00000000。当整数进行加减运算时，所有操作数都使用补码进行运算，否则得不到正确结果。整数加减运算时，符号位也会参与运算，因此可能会出现符号位溢出的情况
移码  // 无论是正数还是负数，都是补码的符号位取反。移码用于做浮点数阶码

补码的设计目的
1、使符号位能与有效值部分一起参加加减运算，从而简化运算规则
2、使减法运算转换为加法运算，进一步简化计算机中运算器的线路设计
3、用原码、反码实现算术运算不方便，它们的0值有两个编码+0和-0

-5对应的补码：  // 正整数的反码和补码是其原码本身
-5对应正数5（00000101） -> 所有位取反（11111010） -> 加1(11111011)

计算机存储数值的格式分为定点数与浮点数，定点数是浮点数的基础
c语言使用定点数格式来存储short、int、long类型的整数，使用浮点数格式来存储float、double类型的小数
溢出  // 有符号数加减，最高位进位与溢出无关，进位自动丢弃，两个正数相加为负数为溢出，两个负数相加为正数为溢出，其他情况都不是溢出，无符号数相加，最高位进位为溢出

计算机中的定点数，都是以补码形式存储，因为，计算机只有加法没有减法，使用补码存储数据，无论数据有无符号，都可以直接进行带符号的加法运算。但进行乘除运算时，需将操作数先转成原码再进行运算（由算法决定），得到结果后，再以补码的形式存储
计算机中的浮点数，一般按IEEE754标准存储，底层由两个定点数组成（尾数、阶码）。浮点数的各种运算，底层也是基于各部分（尾数、阶码）的定点数运算。浮点数有固定的符号位，因此，浮点数都是有符号数
计算机中只有01，数据本身并不包含它是有符号数还是无符号数的信息，也不包含类型等信息。如何理解一份数据，由操作该数据的指令决定。例如，乘除法需要区分有无符号，所以有两种指令：mul/div（使用该指令，就决定了该数是无符号数）和imul/idiv（使用该指令，就决定了该数是有符号数）。相同的数据，不同的指令，会使用不同的处理方式，因此，会得到不同的结果

定点数  // 定点，小数点位置人为约定，固定不变，小数点在内存中不占位数。用定点数格式来存储数值，优点是精度高，因为所有的位都用来存储有效数字，缺点是取值范围太小，不能表示很大或者很小的数字 
定点整数  // 定点整数其实就是整数，小数点固定在最低位之后（最右侧，小数点实际并不存在）。定点整数，可分为有符号整数（即通常讲的有符号数）和无符号整数（即通常讲的无符号数）。符号位，0表示正，1表示负
定点小数  // 是纯小数，没有整数部分。小数点在符号位的下一位，数据的最高位之前（小数点实际并不存在）。定点小数，符号位固定存在，因此，计算机中并没有无符号定点小数，都是有符号定点小数

对于4bit位，有符号数取值范围，-8 -> -1 -> 0 -> 7，用补码表示1000 -> 1111 -> 0000 -> 0111  // 4bit位只通过补码形式表示-8，不能通过原码、反码形式表示-8（超出表示范围），因为，补码的+0和-0一样，所以可以多表示一位负数。4bit位-8补码的推导过程为00001000 -> 11110111 -> 11111000 -> 截取后四位 -> 1000

浮点数  // 小数点位置不固定，是浮动的。小数在内存中一般是以浮点数的形式存储的，其实，浮点数也可以表示整数。浮点数并不是一种数值分类，它和整数、小数、实数等不是一个层面的概念。浮点数是数字（或者说数值）在内存中的一种存储格式，它和定点数是相对的，它能表示大范围的数值但精度较低
浮点数的表示  // 尾数 * 基数^指数，如：3.14 * 10^5
尾数一般用原码存储，阶码（指数）用移码存储
尾数的位数越多，表示的精度越高
阶码的位数越多，表示的范围越大

浮点数运算  // 无论加减乘除
对阶 -> 尾数计算 -> 结果格式化（IEEE754标准）  // 对阶（使两个浮点数，指数部分一致）时，小数向大数看齐。对阶是通过较小数的尾数部分算术右移实现的

浮点数的存储格式
尾数符号（1位）  阶码符号+阶码（8位）  尾数（23位）  // 32位，单精度偏移值，127（0111 1111）
尾数符号（1位）  阶码符号+阶码（11位）  尾数（52位）  // 64位，双精度偏移值，1023（0011 1111 1111）

178.125对应的IEEE 754标准编码：
1、整数部分用除2取余的方法，178 -> 10110010
2、小数部分用乘2取整的方法，0.125 -> 001
3、合并起来，10110010.001
4、转换成二进制的浮点数，把小数点移动到整数位只有1，即为：1.0110010001 * 2^111，111是二进制，由于左移了7位，所以是111
5、确认符号位，178.125为正数，则符号位为0
6、确认指数区域，指数值 + 偏移值，如果178.125是单精度浮点数，111 + 01111111（127，单精度偏移值）-> 10000110
7、确认有效数区域，小数点后面的数，即0110010001
8、最终编码为：0 10000110 01100100010000000000000

大端存储和小端存储  // 主要区别在于存放字节的顺序。大端小端取决于cpu架构，powerpc、aix、SPARC等是大端存储。x86架构处理器（Intel、AMD，PC）、arm架构处理器（arm，手机）是小端存储
大端存储模式(big-endian)：数据的低位（低字节）保存到内存的高地址中，而数据的高位（高字节）保存到内存的低地址中
小端存储模式(little-endian)：数据的低位（低字节）保存到内存的低地址中，而数据的高位（高字节）保存到内存的高地址中。为了在网络中能正确的传输数据，网络字节序都采用大端序传输，当本地字节序不是大端存储模式时，需进行相应的转化

采用小端方式进行数据存放利于计算机处理，因此计算机的内部处理较多用小端字节序
采用大端方式进行数据存放符合人类的正常思维，除了计算机的内部处理，其他的场合几乎都是大端字节序，比如网络传输和文件储存

---
计算机结构  // 冯.诺依曼体系结构
1、运算器  // CA(central arithmetical)
算术逻辑单元ALU
累加寄存器AC  // 通用寄存器，为ALU提供一个工作区，存储临时结果
数据缓冲寄存器DR  // 写内存时，暂存指令或数据 
状态条件寄存器PSW  // 存状态标志和控制标志。争议，有时会将该寄存器归为控制器
2、控制器  // CC(central control)
程序计数器PC  // 存放下一条指令的地址
指令寄存器IR  // 存放即将执行的指令
地址寄存器DR  // 记录cpu当前访问的指令的地址
指令译码器ID  // Instruction Decoder，对指令中的操作码字段进行分析解释
时序部件  // 提供时序控制信号
3、存储器  // M(memory)
主存储器  // 内存
辅助存储器
4、输入设备  // I(input)
5、输出设备  // O(output)
6、外部记录介质  // R(outside recording mediumn)，不属于计算机5大件

晶体管
NMOS  // get端为1则连通
PMOS  // get端为1则关闭

ALU  // 算术逻辑单元
与门，或门，非门, 异或门，拼装成各种加法器，乘法器等
半加器  // 不处理进位
加法器  // 行波进位加法器，超前进位加法器

寄存器  // 每个bit位内部为一个触发器，触发器用于存储数据，如：D触发器
IR  // 指令寄存器，存放当前的指令
PC  // 程序计数器，存放下一条指令的地址
MAR  // 地址寄存器
MDR  // 数据寄存器
F  // 状态标志寄存器
R*  // 通用寄存器（包含段寄存器等）
CS  // 段寄存器，用于中断，CS:IP
IP  // 指令指针寄存器，用于中断
PSW  // 程序状态字寄存器
IR // 中断寄存器，每条指令执行后，扫描该寄存器，若存在中断，判断后，选择是否执行中断响应
...

计算机体系结构flynn分类法
单指令流单数据流SISD
单指令流多数据流SIMD
多指令流单数据流MISD
多指令流多数据流MIMD

时序
时钟周期  // 主频决定
机器周期（cpu周期）  // 完成指令的某一个阶段所需要的时间。一个时钟周期为一个节拍（P），两个节拍为一个状态周期（S），8051中6个状态周期为一个机器周期，即8051中一个机器周期为十二个时钟周期
指令周期  // 完成执行一条指令所需要的时间。指令周期，由若干个机器周期组成，指令的复杂度越高，需要的机器周期数越高。需要一个机器周期的指令称为单周期指令，需要两个机器周期的指令成为双周期指令

指令  // 操作码字段+地址码字段
操作码字段  // 定义计算机要执行的操作
地址码字段  // 包含各操作数的地址和操作结果存放地址等，指令从地址结构的角度可分为三地址指令、二地址指令、一地址指令和零地址指令

寻址方式
立即寻址  // 操作数直接在指令中，速度快、灵活性差
直接寻址  // 指令中存放的是操作数的地址
间接寻址  // 指令中存放了一个地址，这个地址中存放的内容是操作数的地址
寄存器寻址  // 寄存器中直接存放操作数
寄存器间接寻址  // 寄存器中存放的是操作数的地址

指令系统
CISC  // 复杂指令集，指令数量多，可变长格式，支持多种寻址方式
RISC  // 精简指令集，指令数量少，定长格式，大部分为单周期指令，支持的寻址方式少，使用多个通用寄存器，采用流水线

指令体系结构
x86
mips

标量流水线处理器  // 程序执行时，多条指令重叠进行操作的一种准并行处理实现技术。处理指令的三个阶段：取指、分析、执行
超标量流水线处理器  // 多条流水线

层次化存储结构
cpu寄存器
cache  // 高速缓冲存储器，sram，可读写，断电丢失数据，通过6个晶体管组成的电路保存一个bit位信息，不是通过行地址列地址访问。分一级缓存（基本在4KB到64KB之间）、二级缓存（128KB、256KB、512KB、1MB、2MB等）、三级缓存（多核共享，一般8MB等）
内存  // 又称主存，分为两类，随机存储器（ram）和只读存储器（rom）
  内部包含一个核心的存储阵列，有若干行若干列，通过行号+列号即为地址，由此可选中一个存储单元，存储单元的每个bit通过电容保存bit位信息
  字存储单元  // (8 * n)bit，存放一个机器字的存储单元，字地址，如果计算机中可编址的最小单位是字存储单元，则该计算机称为按字编址的计算机
  字节存储单元  // 8bit，存放一个字节的单元，字节地址，如果计算机中可编址的最小单位是字节，则该计算机称为按字节编址的计算机
  dram  // 可读写，断电丢失数据，sdr sdram(single data rate)，ddr sdram(double data rate)
  rom  // 只读，断电不丢失数据
外存  // 硬盘、光盘、u盘等

cache与主存  // 地址映像是指将主存与cache的存储空间划分为若干个大小相同的页（或称为块）
直接相联映像  // 电路简单，冲突率高。分页+主存按cache总容量分区（每个分区内的页号和cache内的页号一一对应）
全相联映像  // 电路复杂，只适用于小容量cache，冲突率低。只分页
组相联映像  // 直接相联和全相联的折中。分页+分区+分组（每个分区内的组号和cache内的组号一一对应，但组内的页随机存储）

主存的编址
按字节编址
按字编址

总线  // 一条总线同一时刻仅允许一个设备发送，但允许多个设备接收
数据总线  // 在cpu和ram之间传送需要处理或需要储存的数据，宽度为内存位宽的整数倍，决定数据数据传输能力
地址总线  // 用来指定在ram之中储存的数据的地址，宽度决定寻址范围，从而决定内存的使用率，如宽度为32的地址，其寻址范围可达2的32次方
控制总线  // 将微处理器控制单元的数据传送到周边设备，一般常见的为USB Bus和1394 Bus

中断  // 并不特指错误异常，类似事件
实模式
保护模式

处理I/O
程序控制  // cpu不停的询问，cpu处理I/O
中断控制  // 中断请求，cpu处理I/O
直接存储器访问(DMA, direct memory access)  // DMAC处理I/O，完成后向cpu发送中断请求

校验码
码距  // 任何一种编码都有许多编字构成，任意两个码字之间最少变化的二进制位数就称为数据校验码的码距
奇偶校验码  // 可检查1位错误，不可纠错
循环校验码CRC  // 可检错，不可纠错
海明校验码  // 可检错，也可纠错

---
操作系统

BIOS(baisc input output system)
DOS  // 早期的操作系统

几个概念
用户空间与内核空间  // 为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操作系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间
进程切换  // 为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行
进程的阻塞  // 正在执行的进程，由于期待的某些事件未发生，则由程序自动执行阻塞原语（Block），使自己由运行状态变为阻塞状态，进程的阻塞是进程自身的一种主动行为
文件描述符fd  // 计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念
缓存I/O  // 又称作标准I/O，操作系统会将I/O的数据缓存在文件系统的页缓存（page cache）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。当一个read操作发生时，它会经历两个阶段，1、 等待数据准备，2、将数据从内核拷贝到进程中

一个IO操作可以分为两个步骤：发起IO请求（等待数据准备）和实际的IO操作（将数据从内核拷贝到进程中）
阻塞IO和非阻塞IO的区别在于第一个步骤是否阻塞，如果需要等到内核IO操作全部完成后，才返回到用户空间执行用户的操作，那么就是传统的阻塞IO。如果用户空间的程序不需要等待内核IO操作全部完成，就可以立即返回用户空间执行用户操作，那么就是非阻塞IO（即用户进程通过向内核轮询，内核会立即返回，并返回一个状态值，用于检测数据是否就绪）
同步IO和异步IO的区别就在于第二个步骤是否阻塞，如果实际的IO操作阻塞用户进程，即用户进程需要自己负责从内核读写数据到进程中，那么就是同步IO。如果实际IO操作不阻塞用户进程，即用户进程无需自己负责读写，而由操作系统内核（异步IO的实现）负责把数据从内核读写到进程中，内核在自己做完两个阶段的IO操作后主动通知用户进程，那么就是异步IO

linux5种I/O模型
同步I/O  // 阻塞I/O、非阻塞I/O、I/O多路复用、信号驱动I/O都属于同步I/O，即第二阶段都阻塞
  阻塞I/O模型  // blocking I/O，第一个阶段阻塞，在linux中，默认情况下所有的socket都是blocking，blocking I/O的特点就是在IO操作的两个阶段都阻塞了
  非阻塞I/O模型  // noblocking I/O，第一个阶段不阻塞（轮询），nonblocking I/O的特点是用户进程需要不断的主动询问内核数据准备好了没有，在内核还在准备数据的情况下会立刻返回
  I/O多路复用模型（事件驱动模型）  // I/O multiplexing，又称为event driven I/O，是最常用的IO模型，第一个阶段阻塞（多选一，等待多个socket中的任意一个变为可读），多路复用的好处就在于一个进程就可以同时处理多个socket的IO请求，有三种机制select、poll、epoll。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。当用户进程调用了select，那么整个进程会被阻塞，而同时，内核会监视所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回
  信号驱动I/O模型（SIGIO）  // signal driven I/O，第一个阶段不阻塞（信号通知，而非轮询），不常用
异步I/O模型  // asynchronous I/O，即第二阶段不阻塞，不常用，（windows iocp？）

I/O多路复用的三种机制select、poll、epoll
I/O多路复用就是通过一种机制，让一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为它们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则
select  // 目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。select的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024
poll  // poll并没有文件描述符最大数量限制，但是数量过大后性能也会下降，select和poll都需要在返回后，通过遍历文件描述符来获取已经就绪的socket
epoll  // 在2.6内核中提出，select和poll的增强版本，epoll更加灵活，没有文件描述符最大数量限制，epoll使用一个文件描述符管理多个描述符，epoll I/O的效率不会随着监视fd的数量的增长而下降。epoll不同于select和poll轮询的方式，而是通过每个fd定义的回调函数来实现的，只有就绪的fd才会执行回调函数
  epoll有两种工作模式：
    LT模式  // level trigger，水平触发，默认，同时支持block和no-block socket，当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件
    ET模式  // edge trigger，边缘触发，高速工作方式，只支持no-block socket，当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件
如果没有大量的idle-connection或者dead-connection，epoll的效率并不会比select/poll高很多，但是当遇到大量的idle-connection，就会发现epoll的效率大大高于select/poll

进程的状态  // 三态模型、五态模型等
就绪
运行
等待  // 又称为阻塞

进程管理
同步  // 直接制约关系
互斥  // 间接制约关系，争夺临界资源
临界区  // 每个进程中访问临界资源的那段代码
信号量  // 一种特殊的变量，代表临界资源的资源总数，用于pv操作
pv操作  // p，荷兰语的passeren，申请资源的操作（等待）。v，荷兰语的verhoog，释放资源的操作（唤醒）。前趋图
死锁  // 一直等待资源。避免死锁的方法，1、有序资源分配法，2、银行家算法

存储管理  // 程序与内存
逻辑地址  // 页号+页内地址
物理地址  // 页帧号（物理块号）+页内地址
页式存储  // 将程序和内存划分为大小相同的块，以页为单位将程序调入内存。页表，页号+物理块号
段式存储  // 按用户作业（程序）中的自然段来划分逻辑空间，然后调入内存空间，段的长度可以不一样。段表，段号+段长+物理段基地址。每个进程都有自己的段表，每个进程都有自己的虚拟地址空间，其中包括代码段、数据段、堆栈段等。操作系统通过段表来管理每个进程的虚拟地址空间，将虚拟地址转换为物理地址，以便进程可以访问内存中的数据和指令
段页式存储  // 段式存储和页式存储的综合体，先分段再分页，一个程序有若干个段，每个段中可以有若干个页，每个页的大小相同，但每个段的大小不同
  段寄存器，段表大小+段表始地址
  段表，段号+状态+页表大小+页表始地址
  页表，页号+状态+物理块号

磁盘管理 
磁道
扇区
存取时间  // 寻道时间+等待时间

文件管理
索引文件结构  // 直接索引、一级间接索引、二级间接索引、三级间接索引

---
数据库系统
数据库模式  // 三级模式，两层映射
e-r模型  // 反应实体与实体之间的关系
关系代数  // 并、交、差、笛卡尔积、投影、选择、联接
规范化理论

---
计算机网络
ipv4  // 32位，网络号+主机号，分ABCDE类
子网划分  // 向主机号借位
子网掩码  // 网络地址全为1，主机地址全为0

---
信息安全
对称加密  // 使用同一套密钥。常见对称加密算法：DES、3DES、RC-5、IDEA等
非对称加密  // 使用公钥和私钥。常见非对称加密算法：RSA、ECC等
数字签名  // 用于证明这个文件是我签发的。用自己的私钥加密（签字），对方用我公开的公钥解密
消息摘要  // 单向散列函数加密，不可逆。常用的消息摘要算法：MD5（散列值128位）、SHA（散列值160位，安全性比MD5高）等
PKI公钥体系  // 公钥管理体系。CA中心负责密钥的注册、更新、注销。使用者从CA中心发放的签名证书中，提取出公钥
DoS  // 拒绝服务，流量攻击
DDoS  // 分布式拒绝服务

---
编译过程
源程序
词法分析  // 正规式+有限自动机。词法错误：非法字符、关键字或标志符拼写错误等
语法分析  // 语法错误：语法结构错误，if endif不匹配，缺分号等
语义分析  // 分静态语义分析（编译时）和动态语义分析（运行时）。语义错误：数据类型错误（静态语义错误）、死循环（动态语义错误）、除0等逻辑错误
中间代码生成
代码优化
目标代码生成
目标程序

---
http协议
http1.0  // tcp短连接，一个http请求完成后断开tcp连接
http1.1  // tcp长连接，连接复用，串行http，完善http缓存机制，支持部分传输，增加宽带利用率...
http2.0  // tcp长连接，并行http，双端通信，支持服务器端推送，压缩header...

---
http缓存机制
Expires  // 强缓存（200 from cache，资源未到期是强制使用缓存，不发送请求），http1.0，存在服务器和客户端时间不同步的缺陷
Cache-Control  // 强缓存，http1.1，优先级高于Expires
Last-Modified  // 协商缓存（304，如果强缓存到期，浏览器会向服务端发起http请求，然后服务端告诉浏览器文件未改变，让浏览器使用本地缓存），与If-Modified-Since配合使用（请求时带上，交由服务器判断），存在只跟踪资源变化时间，而不跟踪资源内容是否改变的缺陷
E-tag  // 协商缓存，http1.1，与If-None-Match配合使用（请求时带上，交由服务器判断），tag实质上是对资源进行MD5编码的hash值