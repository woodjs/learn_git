冯.诺依曼体系结构
控制器  // CC(central control)
运算器  // CA(central arithmetical)，包含通用寄存器
存储器  // M(memory)
输入  // I(input)
输出  // O(output)
外部记录介质  // R(outside recording mediumn)

x86处理器
x86-16 / IA-16
IA-32
x86-64

标量流水线处理器
超标量流水线处理器

指令体系结构
x86
mips

寄存器  // 每个bit位内部为一个触发器，触发器用于存储数据，如：D触发器
IR  // 指令寄存器，存放当前的指令
PC  // 程序计数器，存放下一条指令的地址
MAR  // 地址寄存器
MDR  // 数据寄存器
F  // 状态标志寄存器
R*  // 通用寄存器（包含段寄存器等）
CS  // 段寄存器，用于中断，CS:IP
IP  // 指令指针寄存器，用于中断
PSW  // 程序状态字寄存器
IR // 中断寄存器，每条指令执行后，扫描该寄存器，若存在中断，判断后，选择是否执行中断响应
...

总线
控制总线  // 向主存等，发出控制信号
地址总线  // 宽度决定寻址范围，从而决定主存的使用率，如宽度为32的地址，其寻址范围可达2的32次方
数据总线  // 宽度为主存位宽的整数倍，决定数据数据传输能力
系统总线
...

cpu
sram  // 不是通过行地址列地址访问，高速缓存，一级cache，分为指令数据高速缓存和数据高速缓存，目前一般各为32KB，二级cache，一般256KB，三级cache，多核共享，一般8MB，可读写，断电丢失数据，通过6个晶体管组成的电路保存一个bit位信息

主存
内部包含一个核心的存储阵列，有若干行若干列，通过行号+列号即为地址，由此可选中一个存储单元，存储单元的每个bit通过电容保存bit位信息
字存储单元  // (8 * n)bit，存放一个机器字的存储单元，字地址，如果计算机中可编址的最小单位是字存储单元，则该计算机称为按字编址的计算机
字节存储单元  // 8bit，存放一个字节的单元，字节地址，如果计算机中可编址的最小单位是字节，则该计算机称为按字节编址的计算机
dram  // 可读写，断电丢失数据，sdr sdram(single data rate)，ddr sdram(double data rate)

BIOS(baisc input output system)
rom  // 只读，断电不丢失数据

时序
时钟周期  // 主频决定
机器周期（cpu周期）  // 完成指令的某一个阶段所需要的时间。一个时钟周期为一个节拍（P），两个节拍为一个状态周期（S），8051中6个状态周期为一个机器周期，即8051中一个机器周期为十二个时钟周期
指令周期  // 完成执行一条指令所需要的时间。指令周期，由若干个机器周期组成，指令的复杂度越高，需要的机器周期数越高。需要一个机器周期的指令称为单周期指令，需要两个机器周期的指令成为双周期指令

晶体管
NMOS  // get端为1则连通
PMOS  // get端为1则关闭

ALU  // 算术逻辑单元
与门，或门，非门, 异或门，拼装成各种加法器，乘法器等
半加器  // 不处理进位
加法器  // 行波进位加法器，超前进位加法器

在计算机中，有符号数和无符号数都是以补码形式进行运算，无符号数永远是正数，补码即其本身，补码没有+0和-0之分，有符号和无符号只是程序定义的，计算机没有这个概念
对于4bit位，有符号数取值范围，-8 -> -1 -> 0 -> 7，用补码表示1000 -> 1111 -> 0000 -> 0111
溢出  // 有符号数加减，最高位进位与溢出无关，进位自动丢弃，两个正数相加为负数为溢出，两个负数相加为正数为溢出，其他情况都不是溢出，无符号数相加，最高位进位为溢出

中断  // 并不特指错误异常，类似事件
实模式
保护模式

I/O接口  // 内部包含寄存器，中断控制逻辑等
显卡

处理I/O
程序控制  // cpu不停的询问，cpu处理I/O
中断控制  // 中断请求，cpu处理I/O
直接存储器访问(DMA, direct memory access)  // DMAC处理I/O，完成后向cpu发送中断请求

DOS  // 早期的操作系统

几个概念
用户空间与内核空间  // 为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操作系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间
进程切换  // 为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行
进程的阻塞  // 正在执行的进程，由于期待的某些事件未发生，则由程序自动执行阻塞原语（Block），使自己由运行状态变为阻塞状态，进程的阻塞是进程自身的一种主动行为
文件描述符fd  // 计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念
缓存I/O  // 又称作标准I/O，操作系统会将I/O的数据缓存在文件系统的页缓存（page cache）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。当一个read操作发生时，它会经历两个阶段，1、 等待数据准备，2、将数据从内核拷贝到进程中

linux网络I/O模式
阻塞I/O  // blocking I/O，在linux中，默认情况下所有的socket都是blocking，blocking I/O的特点就是在IO执行的两个阶段都被block了
非阻塞I/O  // noblocking I/O，nonblocking I/O的特点是用户进程需要不断的主动询问kernel数据好了没有，在kernel还准备数据的情况下会立刻返回
I/O多路复用  // I/O multiplexing，又称为event driven I/O，有三种机制select、poll、epoll，select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。当用户进程调用了select，那么整个进程会被block，而同时，kernel会监视所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回
信号驱动I/O  // signal driven I/O，不常用
异步I/O  // asynchronous I/O，IO operation的时候不会将process阻塞，不常用，（windows iocp？），用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了
同步I/O  // synchronous I/O，IO operation的时候会将process阻塞，阻塞I/O、非阻塞I/O、I/O多路复用、信号驱动I/O都属于同步I/O

I/O多路复用的三种机制select、poll、epoll
I/O多路复用就是通过一种机制，让一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为它们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现（kernel）会负责把数据从内核拷贝到用户空间
select  // 目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。select的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024
poll  // poll并没有最大数量限制，但是数量过大后性能也会下降，select和poll都需要在返回后，通过遍历文件描述符来获取已经就绪的socket
epoll  // 在2.6内核中提出，select和poll的增强版本，epoll更加灵活，没有描述符限制，epoll使用一个文件描述符管理多个描述符，epoll I/O的效率不会随着监视fd的数量的增长而下降。epoll不同于select和poll轮询的方式，而是通过每个fd定义的回调函数来实现的，只有就绪的fd才会执行回调函数
  epoll有两种工作模式：
    LT模式  // level trigger，水平触发，默认，同时支持block和no-block socket，当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件
    ET模式  // edge trigger，边缘触发，高速工作方式，只支持no-block socket，当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件
如果没有大量的idle-connection或者dead-connection，epoll的效率并不会比select/poll高很多，但是当遇到大量的idle-connection，就会发现epoll的效率大大高于select/poll

数值的进制
n进制转十进制  // 按权展开法
十进制转n进制  // 短除法，余数逆序表示。对于小数部分，使用短乘法，顺序表示
二进制、八进制、十六进制

数值的码制  // 数值在计算机中有四种编码表示方式
原码  // 当整数进行乘除运算时，所有操作数都使用原码进行运算（由算法决定），得到结果后，再转为补码进行存储
反码  // 正数，不变。负数，除符号位外，取反
补码  // 正数，不变。负数，除符号位外，反码加1。当整数进行加减运算时，所有操作数都使用补码进行运算，否则得不到正确结果。整数加减运算时，符号位也会参与运算，因此可能会出现符号位溢出的情况
移码  // 无论是正数还是负数，都是补码的符号位取反。移码用于做浮点数阶码

补码的设计目的
1、使符号位能与有效值部分一起参加加减运算，从而简化运算规则
2、使减法运算转换为加法运算，进一步简化计算机中运算器的线路设计
3、用原码、反码实现算术运算不方便，它们的0值有两个编码+0和-0

-5对应的补码：  // 正整数的反码和补码是其原码本身
-5对应正数5（00000101） -> 所有位取反（11111010） -> 加1(11111011)

计算机存储数值的格式分为定点数与浮点数，定点数是浮点数的基础
c语言使用定点数格式来存储short、int、long类型的整数，使用浮点数格式来存储float、double类型的小数

计算机中的定点数，都是以补码形式存储，因为，计算机只有加法没有减法，使用补码存储数据，无论数据有无符号，都可以直接进行带符号的加法运算。但进行乘除运算时，需将操作数先转成原码再进行运算（由算法决定），得到结果后，再以补码的形式存储
计算机中的浮点数，一般按IEEE754标准存储，底层由两个定点数组成（尾数、阶码）。浮点数的各种运算，底层也是基于各部分（尾数、阶码）的定点数运算。浮点数有固定的符号位，因此，浮点数都是有符号数
计算机中只有01，数据本身并不包含它是有符号数还是无符号数的信息，也不包含类型等信息。如何理解一份数据，由操作该数据的指令决定。例如，乘除法需要区分有无符号，所以有两种指令：mul/div（使用该指令，就决定了该数是无符号数）和imul/idiv（使用该指令，就决定了该数是有符号数）。相同的数据，不同的指令，会使用不同的处理方式，因此，会得到不同的结果

定点数  // 定点，小数点位置人为约定，固定不变，小数点在内存中不占位数。用定点数格式来存储数值，优点是精度高，因为所有的位都用来存储有效数字，缺点是取值范围太小，不能表示很大或者很小的数字 
定点整数  // 定点整数其实就是整数，小数点固定在最低位之后（最右侧，小数点实际并不存在）。定点整数，可分为有符号整数（即通常讲的无符号数）和无符号整数（即通常讲的无符号数）。符号位，0表示正，1表示负
定点小数  // 是纯小数，没有整数部分。小数点在符号位的下一位，数据的最高位之前（小数点实际并不存在）。定点小数，符号位固定存在，因此，计算机中并没有无符号定点小数，都是有符号定点小数

浮点数  // 小数点位置不固定，是浮动的。小数在内存中一般是以浮点数的形式存储的，其实，浮点数也可以表示整数。浮点数并不是一种数值分类，它和整数、小数、实数等不是一个层面的概念。浮点数是数字（或者说数值）在内存中的一种存储格式，它和定点数是相对的，它能表示大范围的数值但精度较低
浮点数的表示  // 尾数 * 基数^指数，如：3.14 * 10^5
尾数一般用原码存储，阶码（指数）用移码存储
尾数的位数越多，表示的精度越高
阶码的位数越多，表示的范围越大

浮点数运算  // 无论加减乘除
对阶 -> 尾数计算 -> 结果格式化（IEEE754标准）  // 对阶（使两个浮点数，指数部分一致）时，小数向大数看齐。对阶是通过较小数的尾数部分算术右移实现的

浮点数的存储格式
尾数符号（1位）  阶码符号+阶码（8位）  尾数（23位）  // 32位，单精度偏移值，127（0111 1111）
尾数符号（1位）  阶码符号+阶码（11位）  尾数（52位）  // 64位，双精度偏移值，1023（0011 1111 1111）

178.125对应的IEEE 754标准编码：
1、整数部分用除2取余的方法，178 -> 10110010
2、小数部分用乘2取整的方法，0.125 -> 001
3、合并起来，10110010.001
4、转换成二进制的浮点数，把小数点移动到整数位只有1，即为：1.0110010001 * 2^111，111是二进制，由于左移了7位，所以是111
5、确认符号位，178.125为正数，则符号位为0
6、确认指数区域，指数值 + 偏移值，如果178.125是单精度浮点数，111 + 01111111（127，单精度偏移值）-> 10000110
7、确认有效数区域，小数点后面的数，即0110010001
8、最终编码为：0 10000110 01100100010000000000000

大端存储和小端存储  // 主要区别在于存放字节的顺序。大端小端取决于cpu架构，powerpc、aix、SPARC等是大端存储。x86架构处理器（Intel、AMD，PC）、arm架构处理器（arm，手机）是小端存储
大端存储模式(big-endian)：数据的低位（低字节）保存到内存的高地址中，而数据的高位（高字节）保存到内存的低地址中
小端存储模式(little-endian)：数据的低位（低字节）保存到内存的低地址中，而数据的高位（高字节）保存到内存的高地址中。为了在网络中能正确的传输数据，网络字节序都采用大端序传输，当本地字节序不是大端存储模式时，需进行相应的转化

采用小端方式进行数据存放利于计算机处理，因此计算机的内部处理较多用小端字节序
采用大端方式进行数据存放符合人类的正常思维，除了计算机的内部处理，其他的场合几乎都是大端字节序，比如网络传输和文件储存


计算机结构  // 计算机硬件5大件
1、运算器
算术逻辑单元ALU
累加寄存器AC  // 通用寄存器，为ALU提供一个工作区，存储临时结果
数据缓冲寄存器DR  // 写内存是，暂存指令或数据 
状态条件寄存器PSW  // 存状态标志和控制标志。争议，有时会将该寄存器归位控制器
2、控制器
程序计数器PC  // 存放下一条指令的地址
指令寄存器IR  // 存放即将执行的指令
地址寄存器DR  // 记录cpu当前访问的指令的地址
指令译码器ID  // Instruction Decoder，对指令中的操作码字段进行分析解释
时序部件  // 提供时序控制信号
3、存储器
主存储器  // 内存
辅助存储器
4、输入设备
5、输出设备

